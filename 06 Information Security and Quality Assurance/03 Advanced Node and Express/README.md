**Advanced Node and Express**

Authentication is the process or action of verifying the identity of a user or process.

The most common and easiest to use **authentication middleware** for Node.js is **Passport**. It is easy to learn, light-weight, and extremely flexible allowing for many strategies, which we will talk about in later challenges. In addition to authentication we will also look at template engines which allow for use of **Pug** and **web sockets** which allow for real time communication between all your clients and your server.

A **template engine** enables you to use static template files (such as those written in Pug) in your app. At runtime, the template engine replaces variables in a template file with actual values which can be supplied by your server, and transforms the template into a static HTML file that is then sent to the client. This approach makes it easier to design an HTML page and allows for displaying of variables on the page without needing to make an API call from the client.

One of the greatest features of using a template engine is being able to pass **variables** from the server to the template file before rendering it to HTML.

In your Pug file, you're about to use a variable by referencing the variable name as `#{variable_name}` inline with other text on an element or by using an equal side on the element without a space such as `p=variable_name` which sets that p elements text to equal the variable.

We strongly recommend looking at the syntax and structure of Pug [here](https://github.com/pugjs/pug) on their Githubs README. Pug is all about using whitespace and tabs to show nested elements and cutting down on the amount of code needed to make a beautiful site.

Looking at our pug file `index.pug` included in your project, we used the variables `title` and `message`

To pass those alone from our server, you will need to add an object as a second argument to your `res.render` with the variables and their value. For example, pass this object along setting the variables for your index view: `{title: 'Hello', message: 'Please login'});`

It should look like: `res.render(process.cwd() + '/views/pug/index', {title: 'Hello', message: 'Please login'});`

It's time to **set up Passport** so we can finally start allowing a user to register or login to an account! In addition to Passport, we will use **Express-session** to handle sessions. Using this middleware saves the session id as a cookie in the client and allows us to access the session data using that id on the server. This way we keep personal account information out of the cookie used by the client to verify to our server they are authenticated and just keep the key to access the data stored on the server.

You will need to set up the session settings now and initialize Passport. Be sure to first create the variables 'session' and 'passport' to require `'express-session'` and `'passport'` respectively.

To set up your express app to use use the session we'll define just a few basic options. Be sure to add `'SESSION_SECRET'` to your .env file and give it a random value. This is used to compute the hash used to encrypt your cookie!

**Serialization** and **deserialization** are important concepts in regards to authentication. To serialize an object means to convert its contents into a small key essentially that can then be deserialized into the original object. This is what allows us to know whos communicated with the server without having to send the authentication data like username and password at each request for a new page.

To set this up properly, we need to have a **serialize function** and a **deserialize function**. In passport we create these with `passport.serializeUser( OURFUNCTION )` and `passport.deserializeUser( OURFUNCTION )`.

The serializeUser is called with 2 arguments, the full user object and a callback used by passport. Returned in the callback should be a unique key to identify that user- the easiest one to use being the users `_id` in the object as it should be unique as it generated by MongoDb. Similarly deserializeUser is called with that key and a callback function for passport as well, but this time we have to take that key and return the users full object to the callback. To make a query search for a Mongo `_id` you will have to create `const ObjectID = require('mongodb').ObjectID;`, and then to use it you call new `ObjectID(THE_ID)`. Be sure to add MongoDB as a dependency.

Right now we're not loading an actual users object since we haven't set up our database. This can be done many different ways, but for our project we will connect to the database once when we start the server and keep a persistent connection for the full life-cycle of the app.

To do this, add MongoDB as a dependency and require it in your server. (`const mongo = require('mongodb').MongoClient;`)

Now we want to the connect to our database then start listening for requests. The purpose of this is to not allow requests before our database is connected or if there is a database error. To accomplish you will want to encompass your serialization and your app listener. And be sure to set `DATABASE` in your `.env` file to your database's connection string.

A strategy is a way of authenticating a user. You can use a strategy for allowing users to authenticate based on locally saved information (if you have them register first) or from a variety of providers such as Google or Github. For this project we will set up a local strategy. To see a list of the 100's of strategies, visit Passports site [here](http://passportjs.org/).

Add `passport-local` as a dependency and add it to your server as follows: `const LocalStrategy = require('passport-local');`

Now you will have to tell passport to use an instantiated `LocalStartegy` object with a few settings defined. Make sure this as well as everything from this point on is encapsulated in the database connection since it relies on it!

This is defining the process to take when we try to authenticate someone locally. First it tries to find a user in our database with the username entered, then it checks for the password to match, then finally if no errors have popped up that we checked for, like an incorrect password, the users object is returned and they are authenticated.

Many strategies are set up using different settings, general it is easy to set it up based on the README in that strategies repository though. A good example of this is the Github strategy where we don't need to worry about a username or password because the user will be sent to Github's auth page to authenticate and as long as they are logged in and agree then Github returns their profile for us to use.

For this challenge you should add the route `/login` to accept a `POST request`. To authenticate on this route you need to add a middleware to do so before then sending a response. This is done by just passing another argument with the middleware before your `function(req,res)` with your response! The middleware to use is `passport.authenticate('local')`.

`passport.authenticate` can also take some options as an argument such as: `{ failureRedirect: '/' }` which is incredibly useful so be sure to add that in as well. As a response after using the middleware (which will only be called if the authentication middleware passes) should be to redirect the user to `/profile` and that route should render the view `'profile.pug'`.

If the authentication was successful, the user object will be saved in `req.user`.

As in, any user can just go to /profile whether they authenticated or not by typing in the url. We want to prevent this by checking if the user is authenticated first before rendering the profile page. This is the perfect example of when to create a middleware.

The challenge here is creating the middleware function `ensureAuthenticated(req, res, next)`, which will check if a user is authenticated by calling passports `isAuthenticated` on the request which in turn checks for `req.user` is to be defined. If it is then `next()` should be called, otherwise we can just respond to the request with a redirect to our homepage to login. Now add `ensureAuthenticated` as a middleware to the request for the profile page before the argument to the get request containing the function that renders the page.

Now that we can ensure the user accessing the `/profile` is authenticated, we can use the information contained in `'req.user'` on our page!

Creating the logout logic is easy. The route should just unauthenticate the user and redirect to the home page instead of rendering any view. In passport, unauthenticating a user is as easy as just calling `req.logout();` before redirecting.

You may have noticed we also we're not handling missing pages (404), the common way to handle this in Node is with the following middleware.

`app.use((req, res, next) => {`
`res.status(404)`
`.type('text')`
`.send('Not Found');`
`});`

Going back to the information security section you may remember that storing plaintext passwords is never okay. Now it is time to implement **BCrypt** to solve this issue.

Currently on our registeration route, you insert a user's password into the database like the following:`password: req.body.password`. An easy way to implement saving a hash instead is to add the following before your database logic `var hash = bcrypt.hashSync(req.body.password, 12);` and replacing the req.body.password in the database saving with just `password: hash`.

Finally on our authentication strategy we check for the following in our code before completing the process:`if (password !== user.password) { return done(null, false); }`. After making the previous changes, now user.password is a hash. Before making a change to the existing code, notice how the statement is checking if the password is NOT equal then return non-authenticated. With this in mind your code could look as follows to properly check the password entered against the hash: `if (!bcrypt.compareSync(password, user.password)) { return done(null, false); }`
